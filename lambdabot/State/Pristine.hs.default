{-# LANGUAGE Safe #-}

{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE ConstrainedClassMethods #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE EmptyCase #-}
{-# LANGUAGE EmptyDataDecls #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE ExtendedDefaultRules #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE ImplicitParams #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE LiberalTypeSynonyms #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE PackageImports #-}
{-# LANGUAGE ParallelListComp #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE PatternGuards #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE PolymorphicComponents #-}
{-# LANGUAGE PostfixOperators #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeSynonymInstances #-}
-- {-# LANGUAGE UnboxedTuples #-} -- unboxed tuples break @type
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE ViewPatterns #-}

module L where
-- TODO: unordered-containers, vector (+ lenses thereof)?
import Control.Applicative
import Control.Arrow
import qualified Control.Category
import qualified Control.Category as C
import Control.Category (Category)
import Control.Exception
import Control.Exception.Lens
import Control.Lens hiding (elements, index, indices, levels, uncons)
import qualified Control.Lens
import qualified Control.Lens as Lens
import Control.Monad
import Control.Monad.Cont
import Control.Monad.Except
import Control.Monad.Error.Lens
import Control.Monad.Fix
import Control.Monad.Identity
-- import Control.Monad.Instances
import Control.Monad.RWS
import Control.Monad.Reader
import Control.Monad.ST
import Control.Monad.State
import Control.Monad.Writer
-- import Control.Parallel
-- import Control.Parallel.Strategies
-- import Control.Parallel.Strategies.Lens
import Data.Array
import Data.Array.Lens
import Data.Bits
import Data.Bits.Lens
import Data.Bool
import Data.Char
import Data.Complex
import Data.Complex.Lens
import Data.Data
import Data.Data.Lens
-- import Data.Default
import Data.Dynamic
import Data.Dynamic.Lens
import Data.Either
import Data.Eq
import Data.Fixed
import Data.Function
import Data.Graph
import Data.Int
import Data.Ix
import Data.List
import Data.List.Lens
import qualified Data.List.NonEmpty
import qualified Data.List.NonEmpty as NE
import Data.List.NonEmpty (NonEmpty (..))
import Data.List.Split
-- import Data.List.Split.Lens
import Data.Maybe
import Data.Monoid
-- import Data.Number.BigFloat
-- import Data.Number.CReal
-- import Data.Number.Interval
-- import Data.Number.Natural
-- import Data.Number.Symbolic hiding (var)
-- import qualified Data.Number.Symbolic
-- import qualified Data.Number.Symbolic as Sym
import Data.Ord
import Data.Ratio
import Data.STRef
import Data.Tree
import Data.Tree.Lens
import Data.Tuple
import Data.Typeable
import Data.Typeable.Lens
import Data.Void
import Data.Word
import Debug.SimpleReflect hiding (op, Associativity(..), Expr(..))
import Debug.SimpleReflect (Expr())
import qualified Debug.SimpleReflect
import Numeric
import Numeric.Lens
import ShowFun
import System.Random hiding (split)
import qualified System.Random
import qualified System.Random as R
import Lambdabot.Plugin.Haskell.Eval.Trusted hiding ((.&.), IsList (..), IsString (..))
import qualified Lambdabot.Plugin.Haskell.Eval.Trusted as GHC.Exts (Constraint, IsList (..), IsString (..))
import Text.PrettyPrint.HughesPJ hiding (empty, first, (<>))
import qualified Text.PrettyPrint.HughesPJ
import Text.Printf
import qualified Data.Text
import qualified Data.Text as T
import qualified Data.ByteString
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as BSC
import qualified Data.ByteString.Lazy
import qualified Data.ByteString.Lazy as BSL
import qualified Data.ByteString.Lazy.Char8
import qualified Data.ByteString.Lazy.Char8 as BSLC
import Data.ByteString.Lens
import Data.Foldable
-- import qualified Data.Foldable as F
import qualified Data.IntMap
import qualified Data.IntMap as IM
import qualified Data.IntSet
import qualified Data.IntSet as IS
import qualified Data.Map
import qualified Data.Map as M
import qualified Data.Sequence
import qualified Data.Sequence as Seq
import Data.Sequence.Lens
import qualified Data.Set
import qualified Data.Set as S
import Data.Set.Lens
import Data.Traversable
-- import Math.NumberTheory.GCD
-- import Math.NumberTheory.Logarithms
-- import Math.NumberTheory.Moduli
-- import Math.NumberTheory.MoebiusInversion
-- import Math.NumberTheory.Powers
-- import Math.NumberTheory.Primes
-- import Math.NumberTheory.Primes.Factorisation.Certified
-- import Math.NumberTheory.Primes.Testing.Certificates

default ((),Integer,Double)

infixl 0 `asAppliedTo`
asAppliedTo :: (a -> b) -> a -> a -> b
asAppliedTo f _ = f

{-# LINE 1 "<local>" #-}
